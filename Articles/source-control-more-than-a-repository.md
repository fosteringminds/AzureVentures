# Source Control - More than just a repository

I find keeping a repository even for very small projects incredibly useful. In fact these days I hardly start a project without creating a code repository first. You just never know where you might need the code again. I find myself initializing a new git repository almost by habit when creating a new folder for a new project. Having a git-based code repository is great because you can create branches of work against the repository. You can commit or revert changes as you choose against by creating branches locally. If you go too far with a feature you can easily revert to a previous version, or in git terms stash it. Ideally though you may want to host your code in a remote repository. Your remote repository should provide more than just a way to keep your code safe though. Let me elaborate.

Before I continue its worth noting that the git version control system has become the de facto standard. The version control system Subversion (SVN) is still in use by many teams. Mercurial was until recently still supported by BitBucket. BitBucket, however, [discontinued support for Mercurial](https://bitbucket.org/blog/sunsetting-mercurial-support-in-bitbucket).  in favour of git. Cloud-hosted git providers such as GitHub, Azure Devops, BitBucket, AWS CodeCommit, Google Cloud Repositories and GitLab mostly use the git version control system.

Cloud-hosted git repositories are great for team collaboration. Why? Because they provide so much more than just a place to keep your code. Azure Devops, for instance, not only provides a place to keep your code but also provides integrated project management (think Agile) support through [Azure Boards](https://azure.microsoft.com/en-us/services/devops/boards/). GitHub provides [projects](https://github.com/features/project-management/) as a way to track work. It's important to recognize the integration of your code repository with the project management tools provided by Azure Devops and GitHub. Your team typically creates user stories with tasks or features using Azure Devops Boards, for instance. The stories (features) are then displayed on a project board. The team then performs work against a task or a feature. The work may involve writing code by a developer. In the case of a developer they would typically start the development of a task or feature by creating a git branch in their local environment. Work will be done on the feature or task with regular commits on a local branch. When the developer is finished with the work they will push the local branch to the remote repository. All the details of the commits are then tracked against the project item. Azure Devops, for instance, shows the commit details against a feature or task. In my mind the project item is no longer just a "sticky" (using Agile terms) to track progress but also a valuable source of information. It promotes transparency. Non-technical stakeholders can sign-in to Azure Devops, for instance, to look at a project's progress.

In many environments developers will create pull requests from the branches they pushed. A pull request is a great opportunity to collaborate - reviewing code. Both Azure Devops and GitHub provide great support for reviewing code from pull requests. Reviewing code is a great team collaboration mechanism. Teams should perform code reviews as it improves the quality of a project immeasurably. It also helps build trust. An approved pull request will merge code into a main branch such as master or development. If configured, the merge will trigger a CI/CD pipeline. CI/CD pipelines delivers updates to your project without any human intervention - continuously. With the deployment process being automated the quality of your project increases because it happens after every merge of a pull request. Features can be tested quicker. Feedback from testers (QA) can come quicker. Bugs are reported quicker. Devs fix bugs quicker.

Source control, therefore, must be seen as more than just keeping your code in a repository. Your source control strategy should ideally provide a collaborative experience for your team. It should also provide a way to speed up the iterations to your project through constant integration using CI/CD pipelines.

